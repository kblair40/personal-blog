---
title: "Node Clustering"
publishedAt: '2025-03-22'
summary: "How to implement clustering with a Node server"
live: "false"
---


## Node's Event Loop is Single-Threaded

**The Problem:** Node's event loop is single-threaded, presenting the potential for blocking operations 
that can delay the processing of other I/O operations.

The diagram below is effectively the request/response cycle in an Express application. A request is made to a node server 
running in a single thread, which process that request and then sends a response. For smaller apps, this is a 
perfectly valid setup. 

<div className="mx-auto w-full flex justify-center items-center gap-x-1 relative bg-neutral-50 rounded-sm pt-8 pb-3 px-4">

<section className="p-4 flex justify-center items-center border border-neutral-200">
    <span>Request</span>
</section>

<span className="text-2xl">&#8594;</span>

<span className="absolute top-1 left-1/2 -translate-x-1/2 font-medium">Single Thread</span>
<section className="flex flex-col items-center">
<div className="flex justify-center items-center p-4 border border-neutral-300">
    <div className="p-4 flex justify-center items-center border border-neutral-200">
        <span className="font-medium">Node Server</span>
    </div>
</div>
</section>

<span className="text-2xl">&#8594;</span>

<section className="p-4 flex justify-center items-center border border-neutral-200">
    <span>Response</span>
</section>

</div>

But, what if we have requests that require large amounts of processing power? Or many requests coming at a rapid pace?

The Node server will not be able to process incoming requests as fast as we would like in order for our app to be considered 
highly performant.  

To demonstrate this, I recommend running the example below inside of a new express app. You should only need to install the express library in order to run the code. If you're unable to run this code 
on your own, you can trust that I am not misrepresenting how the request/response cycle works.

```
// req-res-demo.js 

const express = require('express');

const app = express();

function doWork(duration) {
    const start = Date.now();
    while (Date.now() - start < duration) {
        /* While the current time, less start time, is less 
             than duration, execute this loop's body.
           While this loop is being executed, the main thread is 
             blocked, meaning no other actions can be performed
             by our app. */
    }
}

app.get('/', (req, res) => {
    doWork(5000); // doWork will take 5 seconds to complete
    res.send('Hello');
})

app.listen(3001); // Any port you prefer here is fine
```

Start the server by running <code>node \<filename\></code> in your terminal. In your browser, 
open a tab to <span className="font-medium">localhost:3001</span>. 
If you chose a different port, replace 3001 with that port. 

Notice that no response was received from the server for ~5 seconds. 
This is due to the call to doWork taking 5 seconds to complete. 
While waiting for the function to complete, no other incoming requests could be processed. 
If you're using Chrome or a Chromium based browser, you can confirm this in your browser's Network tab.

<div className="relative w-full h-80">
<Image 
    fill
    alt="placeholder" 
    src="/evt-loop-blocked1.png"
/>
</div>
    {/* className="border border-neutral-300" */}


To simulate a request coming in while waiting for doWork to complete in the first request, open a second tab 
in your browser. Once both tabs have received responses, try to refresh one tab, then navigate to the other tab 
as fast as you can, and refresh it as well. 

On the tab you refreshed first, you should see it takes roughly the same amount of time as the prior example. 
The request sent from the second tab could not start to be processed until processing of the first request completed, 
so it will take longer to resolve.  It took me ~1.5 seconds after refreshing the first tab, to switch tabs and refresh 
the second tab, so the second request should start processing ~3.5 seconds after it was sent. The second request is 
identical to the first request, but since we had to wait ~3.5 seconds for the first request to complete, it took 
~8.5 seconds to complete.

## Clustering

{/* <Mermaid chart={`graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
`} 
config={{ mermaid: { look: "handDrawn", theme: "neutral" } }}
/> */}

```mermaid
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
```

```mermaid
---
config:
  look: handDrawn
  theme: neutral
---
flowchart LR;
    A[Request]-->B[Node Server];
    B-->C[Response];
```
{/* <Diagram /> */}