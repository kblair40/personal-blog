---
title: "Understanding Node's Event Loop"
publishedAt: '2025-03-20'
summary: "Explore and understand Node's event loop"
# summary: 'Explore the enduring debate between using spaces and tabs for code indentation, and why this choice matters more than you might think.'
---

Node's event loop is notoriously complicated, but should be fully understood as it is what 
provides the ability to perform non-blocking I/O operations.

To start, it is important to note that Node will execute a file entirely, line by line, before entering the event loop.
While executing the file, Node will store all Timers (setTimeout, setInterval, setImmediate), OS tasks (ex. server listening to a port) and operations (ex. fs module readFile).
Some consider this a phase of the event loop, but since it all runs before the event loop begins, it technically is not.


The event loop itself can be thought of as a while loop that will terminate when there are no Timers, OS tasks or operations left to be executed. 

```
const pendingTimers = [];
const pendingOSTasks = [];
const pendingOperations = [];

function shouldContinue() {
    // returns true IF there are any remaining Timers, 
    // OS tasks or operations
    return pendingTimers.length 
        || pendingOTasks.length 
        || pendingOperations.length;
}

while(shouldContinue()) {
    // Event loop body runs if shouldContinue returns true
    // The phases of this loop are described in detail further down
}
```

<br />

## Event Loop Phases

We will go into detail on each step, but the diagram below can suffice as a high level overview.

<ArrowDiagram 
    blockClassName="border-neutral-400"
    blocks={[
        <div><strong>Check Timers:</strong> Node checks for any pending Timers, and calls any that are ready to be called</div>,
        <div><strong>Pending Callbacks:</strong> Node checks for any OS tasks and operations and calls any pending callbacks</div>,
        <div>
            <p className="!mt-0 !mb-1"><strong>Poll:</strong> Node pauses. It will continue when...</p>
            <ul className="mt-0 text-left leading-snug">
                <li> a new pending OS task completes</li>
                <li>a new pending operation completes</li>
                <li>a timer is about to complete</li>
            </ul>
        </div>,
        <div><strong>Check:</strong> If any callbacks have been registered with setImmediate, they are executed here</div>,
        <div>
            <div><strong>Close Callbacks:</strong> Any 'close' events are handled</div>
            <div>Ex.<code>readStream.on('close', ...)</code></div>
        </div>        
    ]}
/>

<br />
#### 1. Check Timers 
Node checks for any callbacks registered via setTimeout or setInterval and, if they are ready to be executed, executes them. 
Technically, setImmediate is a Timer, however those callbacks are not executed until after the poll phase. 

#### 2. Pending Callbacks
Any callbacks from system (usually I/O) operations are executed here. An example would be a callback passed to the fs module's readFile function. 

```
fs.readFile("myfile.txt", (err, data) => {
    // Code here will be executed in this phase
})
```

Any network operations, like an http request, fall under the 'system operations' umbrella, and will also be executed here. 

#### 3. Poll
What exactly happens here depends on if there are or are not any tasks in the poll queue.  

<strong>If tasks are in the poll queue...</strong>
Those tasks will be completed in first-in first-out (FIFO) fashion, synchronously, until all have been completed.

<strong>If the poll queue is empty...</strong>
If any callbacks have been scheduled via setImmediate, the poll phase ends and the event loop moves to the next phase.
Otherwise, the event loop waits for callbacks to be added to the queue, and executes them as they arrive. 

When the poll queue is empty, the event loop checks for any timers with callbacks ready to be executed.  If any exist, 
the event loop wraps back to the Timers phase to execute those callbacks.

#### 4. Check 
This is where any callbacks registered via [setImmediate](https://nodejs.org/en/learn/asynchronous-work/understanding-setimmediate#understanding-setimmediate) are executed. 

#### 5. Close Callbacks 
Any 'close' event handlers are executed here. This could be a socket, server, readStream or any other type that allows for 'close' event callbacks. 
For example...

```
const fs = require('fs');

const readStream = fs.createReadStream('/path/to/file.txt');

// The 'close' callback will be executed in this phase, 
// even if readStream closed some time earlier
readStream.on('close', () => {
    // Do some cleanup here
})
```

<br/>

## Blocking the Event Loop
The single-threaded nature of Node's event loop presents potential for blocking operations 
that can delay the processing of other I/O operations.

<div className="mx-auto w-full flex justify-center items-center gap-x-1 relative bg-neutral-50 rounded-sm pt-8 pb-2 px-4">

<section className="p-4 flex justify-center items-center border border-neutral-200">
    <span>Request</span>
</section>

<span className="text-2xl">&#8594;</span>

<span className="absolute top-1 left-1/2 -translate-x-1/2 font-medium">Single Thread</span>
<section className="flex flex-col items-center">
<div className="flex justify-center items-center p-4 border border-neutral-300">
    <div className="p-4 flex justify-center items-center border border-neutral-200">
        <span className="font-medium">Node Server</span>
    </div>
</div>
</section>

<span className="text-2xl">&#8594;</span>

<section className="p-4 flex justify-center items-center border border-neutral-200">
    <span>Response</span>
</section>

</div>

This is effectively the request/response cycle in an Express application. A request is made to a node server 
running in a single thread, which process that request and then sends a response. For smaller apps, this is a 
perfectly valid setup. 

But, what if we have requests that require large amounts of processing power? Or many requests coming at a rapid pace?

The Node server will not be able to process incoming requests as fast as we would like in order for our app to be considered 
highly performant.  

I recommend running the example below inside of a new express app.  
You should only need to install the express library in order to run the code. 

```
const express = require('express');

const app = express();

function doWork(duration) {
    const start = Date.now();
    while (Date.now() - start < duration) {
        /* While the current time, less start time, is less 
             than duration, execute this loop's body.
           While this loop is being executed, the main thread is 
             blocked, meaning no other actions can be performed
             by our app. */
    }
}

app.get('/', (req, res) => {
    doWork(5000); // doWork will take 5 seconds to complete
    res.send('Hello');
})

app.listen(3001); // Any port you prefer here is fine
```

In a browser, open a tab to <span className="font-medium">localhost:3001</span>. 
If you chose a different port, replace 3001 with that port. 

Notice that no response was received from the server for ~5 seconds. 
This is due to the call to doWork taking 5 seconds to complete. 
While waiting for the function to complete, no other incoming requests could be processed. 
If you're using Chrome or a Chromium based browser, you can confirm this in your browser's Network tab.

<div className="relative w-full h-80">
<Image 
    fill
    alt="placeholder" 
    src="/evt-loop-blocked1.png"
/>
</div>
    {/* className="border border-neutral-300" */}


To simulate a request coming in while waiting for doWork to complete in the first request, open a second tab 
in your browser. Once both tabs have received responses, try to refresh one tab, then navigate to the other tab 
as fast as you can, and refresh it as well. 

On the tab you refreshed first, you should see it takes roughly the same amount of time as the prior example. 
The request sent from the second tab could not start to be processed until processing of the first request completed, 
so it will take longer to resolve.  It took me ~1.5 seconds after refreshing the first tab, to switch tabs and refresh 
the second tab, so the second request should start processing ~3.5 seconds after it was sent. The second request is 
identical to the first request, but since we had to wait ~3.5 seconds for the first request to complete, it took 
~8.5 seconds to complete.

